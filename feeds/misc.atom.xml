<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>寒玉 Blog - misc</title><link href="xixuebin.github.io/" rel="alternate"></link><link href="xixuebin.github.io/feeds/misc.atom.xml" rel="self"></link><id>xixuebin.github.io/</id><updated>2017-06-27T10:27:02+08:00</updated><entry><title>Google Gunice</title><link href="xixuebin.github.io/google-gunice-ch.html" rel="alternate"></link><published>2017-06-27T10:27:02+08:00</published><updated>2017-06-27T10:27:02+08:00</updated><author><name>kevin.xi</name></author><id>tag:None,2017-06-27:xixuebin.github.io/google-gunice-ch.html</id><summary type="html"></summary><content type="html">&lt;hr&gt;
&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#google-guice"&gt;Google Guice&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#guice%E6%A6%82%E8%BF%B0"&gt;Guice概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#guice%E7%89%B9%E7%82%B9"&gt;Guice特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"&gt;最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#guice%E6%96%87%E6%A1%A3"&gt;Guice文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#guice-vs-spring"&gt;Guice vs Spring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /MarkdownTOC --&gt;

&lt;h1&gt;Google Guice&lt;/h1&gt;
&lt;p&gt;Guice是google开源的一个依赖注入类库,相比Spring Ioc来说更小更快,Elasticsearch,Druid大量使用了Guice.&lt;/p&gt;
&lt;h2&gt;Guice概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Guice是google开源的依赖注入类库,通过Guice减少了对工厂方法和new的使用,使得代码更容易交付,测试和重用&lt;/li&gt;
&lt;li&gt;Guice可以帮助我们更好地设计API,它是一个轻量级的非侵入式的类库&lt;/li&gt;
&lt;li&gt;对开发友好,当异常发生的时候能提供更多有用的信息用于分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Guice特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;注入定义简单&lt;/li&gt;
&lt;li&gt;支持多种注入方式&lt;/li&gt;
&lt;li&gt;可扩展&lt;/li&gt;
&lt;li&gt;效率高&lt;/li&gt;
&lt;li&gt;自定义注解&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;最佳实践&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最小化可变性&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;尽可能注入的是不可变对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;只注入直接依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不用注入一个实例来获取真正需要的实例,增加复杂性且不易测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;避免循环依赖&lt;/li&gt;
&lt;li&gt;避免静态状态&lt;/li&gt;
&lt;li&gt;采用@Nullable&lt;/li&gt;
&lt;li&gt;模块的处理必须要快并且无副作用&lt;/li&gt;
&lt;li&gt;在Providers绑定中当心IO问题&lt;/li&gt;
&lt;li&gt;不用在模块中处理分支模块&lt;/li&gt;
&lt;li&gt;尽可能不要暴露构造器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Guice文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/google/guice/wiki/Motivation"&gt;用户指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://google.github.io/guice/api-docs/4.0/javadoc/index.html"&gt;最新版API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=hBVJbzAagfs"&gt;Bob Lee视频教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Guice vs Spring&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;&lt;/th&gt;
&lt;th align="left"&gt;Spring&lt;/th&gt;
&lt;th align="left"&gt;Guice&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;使用xml&lt;/td&gt;
&lt;td align="left"&gt;使用将类与类之间的关系隔离到xml中，由容器负责注入被调用的对象，因此叫做依赖注入&lt;/td&gt;
&lt;td align="left"&gt;不使用xml,将类与类之间的关系隔离到Module中，声名何处需要注入，由容器根据Module里的描述，注入被调用的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;使用Annotation&lt;/td&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;使用支持自定义Annotation标注，对于相同的接口定义的对象引用，为它们标注上不同的自定义Annotation注释，就可以达到同一个类里边的同一个接口的引用，注射给不同的实现，在Module里用标注做区分，灵活性大大增加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;运行效率&lt;/td&gt;
&lt;td align="left"&gt;装载spring配置文件时，需解析xml，效率低，getBean效率也不高，不过使用环境不会涉及到getBean，只有生产环境的时候会用到getBean,在装载spring应用程序的时候，已经完成全部的注射，所以这个低效率的问题不是问题&lt;/td&gt;
&lt;td align="left"&gt;使用Annotation，cglib, 效率高与spring最明显的一个区别，spring是在装载spring配置文件的时候把该注入的地方都注入完，而Guice呢，则是在使用的时候去注射，运行效率和灵活性高。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;类耦合度&lt;/td&gt;
&lt;td align="left"&gt;耦合度低，强调类非侵入，以外部化的方式处理依赖关系，类里边是很干净的，在配置文件里做文章，对类的依赖性极低。&lt;/td&gt;
&lt;td align="left"&gt;耦合度低，强调类非侵入，以外部化的方式处理依赖关系，类里边是很干净的，在配置文件里做文章，对类的依赖性极低。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;类编写时&lt;/td&gt;
&lt;td align="left"&gt;需要编写xml，配置Bean，配置注入&lt;/td&gt;
&lt;td align="left"&gt;只需声明为@inject,等着被注入,最后在统一的Module里声明注入方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;仅支持IOC&lt;/td&gt;
&lt;td align="left"&gt;否，spring目前已经涉猎很多部分&lt;/td&gt;
&lt;td align="left"&gt;是，目前仅仅是个DI容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;是否易于代码重构&lt;/td&gt;
&lt;td align="left"&gt;统一的xml配置入口，更改容易&lt;/td&gt;
&lt;td align="left"&gt;配置工作是在Module里进行，和spring异曲同功&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;配置复杂度&lt;/td&gt;
&lt;td align="left"&gt;在xml中定位类与类之间的关系,难度低&lt;/td&gt;
&lt;td align="left"&gt;代码级定位类与类之间的关系,难度稍高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://tech.it168.com/zt/guice/"&gt;http://tech.it168.com/zt/guice/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ginobefunny.com/post/learning_guice/"&gt;http://ginobefunny.com/post/learning_guice/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hao.jobbole.com/guice/"&gt;http://hao.jobbole.com/guice/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/greengerong/guice-demo"&gt;https://github.com/greengerong/guice-demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.itpub.net/13270562/viewspace-217874/"&gt;http://blog.itpub.net/13270562/viewspace-217874/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="gunice"></category></entry></feed>